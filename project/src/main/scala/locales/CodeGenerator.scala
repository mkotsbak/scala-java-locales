package locales

/**
  * Created by cquiroz on 7/31/16.
  */
object CodeGenerator {
  import treehugger.forest._
  import definitions._
  import treehuggerDSL._

  val autoGeneratedCommend = "Auto-generated code from CLDR definitions, don't edit"

  def buildClassTree(packageObject: String, ldmls: List[XMLLDML],
      only: List[String], parentLocales: Map[String, List[String]]): Tree = {
    val langs = ldmls.map(_.scalaSafeName.split("_").toList)
    // Root must always be available
    val root = ldmls.find(_.scalaSafeName == "root").get

    val objectBlock = if (only.nonEmpty) {
       ldmls.filter(a => only.contains(a.scalaSafeName))
        .map(buildClassTree(root, langs, parentLocales))
      } else {
        ldmls.map(buildClassTree(root, langs, parentLocales))
      }

    BLOCK (
      List(IMPORT("locales.cldr.LDML") withComment autoGeneratedCommend,
      IMPORT("locales.cldr.LDMLLocale"),
      IMPORT("locales.cldr.Symbols"),
      IMPORT("locales.cldr.CalendarSymbols"),
      IMPORT("locales.cldr.CalendarPatterns"),
      IMPORT("locales.cldr.NumberPatterns"),
      IMPORT("locales.cldr.data.numericsystems._")) ++ objectBlock
    ) inPackage "locales.cldr.data"
  }

  def findParent(root: XMLLDML, langs: List[List[String]],
      ldml: XMLLDML, parentLocales: Map[String, List[String]]): Option[String] = {
    // http://www.unicode.org/reports/tr35/#Locale_Inheritance
    parentLocales.find(_._2.contains(ldml.fileName)).fold(
      // This searches based on the simple hierarchy resolution based on bundle_name
      // http://www.unicode.org/reports/tr35/#Bundle_vs_Item_Lookup
      ldml.scalaSafeName.split("_").reverse.toList match {
        case x :: Nil if x == root.scalaSafeName => None
        case x :: Nil => Some(root.scalaSafeName)
        case x :: xs if langs.contains(xs.reverse) => Some(xs.reverse.mkString("_"))
      }
    )(p => Some(p._1))
  }

  def buildClassTree(root: XMLLDML, langs: List[List[String]], parentLocales: Map[String, List[String]])
      (ldml: XMLLDML): Tree = {
    val ldmlSym = getModule("LDML")
    val ldmlNumericSym = getModule("Symbols")
    val ldmlCalendarSym = getModule("CalendarSymbols")
    val ldmlCalendarPatternsSym = getModule("CalendarPatterns")
    val ldmlNumberPatternsSym = getModule("NumberPatterns")
    val ldmlLocaleSym = getModule("LDMLLocale")

    val parent = findParent(root, langs, ldml, parentLocales).fold(NONE)(v => SOME(REF(v)))

    val ldmlLocaleTree = Apply(ldmlLocaleSym, LIT(ldml.locale.language),
      ldml.locale.territory.fold(NONE)(t => SOME(LIT(t))),
      ldml.locale.variant.fold(NONE)(v => SOME(LIT(v))),
      ldml.locale.script.fold(NONE)(s => SOME(LIT(s))))

    val defaultNS = ldml.defaultNS.fold(NONE)(s => SOME(REF(s.id)))

    // Locales only use the default numeric system
    val numericSymbols = ldml.digitSymbols.map { case (ns, symb) =>
      val decimal = symb.decimal.fold(NONE)(s => SOME(LIT(s)))
      val group = symb.group.fold(NONE)(s => SOME(LIT(s)))
      val list = symb.list.fold(NONE)(s => SOME(LIT(s)))
      val percent = symb.percent.fold(NONE)(s => SOME(LIT(s)))
      val minus = symb.minus.fold(NONE)(s => SOME(LIT(s)))
      val perMille = symb.perMille.fold(NONE)(s => SOME(LIT(s)))
      val infinity = symb.infinity.fold(NONE)(s => SOME(LIT(s)))
      val nan = symb.nan.fold(NONE)(s => SOME(LIT(s)))
      val exp = symb.exp.fold(NONE)(s => SOME(LIT(s)))
      Apply(ldmlNumericSym, REF(ns.id),
        symb.aliasOf.fold(NONE)(n => SOME(REF(n.id))), decimal, group, list,
        percent, minus, perMille, infinity, nan, exp)
    }

    val gc = ldml.calendar.map { cs =>
      Apply(ldmlCalendarSym, LIST(cs.months.months.map(LIT(_))), LIST(cs.months.shortMonths.map(LIT(_))),
        LIST(cs.weekdays.weekdays.map(LIT(_))), LIST(cs.weekdays.shortWeekdays.map(LIT(_))),
        LIST(cs.amPm.amPm.map(LIT(_))), LIST(cs.eras.eras.map(LIT(_))))
    }.fold(NONE)(s => SOME(s))

    val gcp = ldml.datePatterns.map { cs =>
      def patternToIndex(i: String) = i match {
        case "full" => 0
        case "long" => 1
        case "medium" => 2
        case "short" => 3
        case x => throw new IllegalArgumentException(s"Unknown format $x, abort ")
      }

      val dates = MAKE_MAP(cs.datePatterns.map(p => TUPLE(LIT(patternToIndex(p.patternType)), LIT(p.pattern))))
      val times = MAKE_MAP(cs.timePatterns.map(p => TUPLE(LIT(patternToIndex(p.patternType)), LIT(p.pattern))))
      Apply(ldmlCalendarPatternsSym, dates, times)
    }.fold(NONE)(s => SOME(s))

    val np = {
      val decimal = ldml.numberPatterns.decimalFormat.fold(NONE)(s => SOME(LIT(s)))
      val percent = ldml.numberPatterns.percentFormat.fold(NONE)(s => SOME(LIT(s)))
      Apply(ldmlNumberPatternsSym, decimal, percent)
    }

    OBJECTDEF(ldml.scalaSafeName) withParents Apply(ldmlSym, parent,
      ldmlLocaleTree, defaultNS, LIST(numericSymbols), gc, gcp, np)
  }

  def metadata(codes: List[String], languages: List[String], scripts: List[String]): Tree = {
    BLOCK (
      OBJECTDEF("metadata") := BLOCK(
        LAZYVAL("isoCountries", "Array[String]") :=
          ARRAY(codes.map(LIT(_))) withComment autoGeneratedCommend,
        LAZYVAL("isoLanguages", "Array[String]") :=
          ARRAY(languages.map(LIT(_))) withComment autoGeneratedCommend,
        LAZYVAL("scripts", "Array[String]") :=
          ARRAY(scripts.map(LIT(_))) withComment autoGeneratedCommend
      )
    ) inPackage "locales.cldr.data"
  }

  def numericSystems(ns: Seq[NumericSystem]): Tree = {
    val ldmlNS = getModule("NumberingSystem")

    BLOCK (
      IMPORT("locales.cldr.NumberingSystem") withComment autoGeneratedCommend,
      OBJECTDEF("numericsystems") := BLOCK(
        ns.map(s =>
          LAZYVAL(s.id, "NumberingSystem") :=
            Apply(ldmlNS, LIT(s.id), LIST(s.digits.toList.map(LIT(_))))
        )
      )
    ) inPackage "locales.cldr.data"
  }

  def calendars(c: Seq[Calendar]): Tree = {
    val ldmlNS = getModule("Calendar")

    BLOCK (
      IMPORT("locales.cldr.Calendar") withComment autoGeneratedCommend,
      OBJECTDEF("calendars") := BLOCK(
        (LAZYVAL("all", "List[Calendar]") := LIST(c.map(c => REF(c.scalaSafeName)))) +:
        c.map(c =>
          LAZYVAL(c.scalaSafeName, "Calendar") :=
            Apply(ldmlNS, LIT(c.id))
        )
      )
    ) inPackage "scala.scalajs.locale.cldr.data"
  }
}
